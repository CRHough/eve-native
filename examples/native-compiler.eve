Domains
------------------------------------------------------

Domains help us represent the valid values of some value within a block. Knowing
the domain for both the inputs and outputs of a block help us dramatically prune
the otherwise very cyclic graph that most Eve programs end up forming. There are
a few types of domains:

    commit
      [#define/domain type:"unknown" sort:1]
      [#define/domain type:"removed" sort:2]
      [#define/domain type:"string" sort:3]
      [#define/domain type:"record" sort:4]
      // numbers can also optionally have a from/to to help be even more
      // specific about their bounds
      [#define/domain type:"number" sort:5]
      [#define/domain type:"multi-type" sort:6]
    end

One of the most important things for us to be able to do with domains is take a
set of them and find out what the most specific domain we have is. The first
step there is to check if we have multiple types.

    search
      set = [#domain-set domain: [#domain type]]
      [#define/domain type sort > 2]
      count = gather/count[for:type per:set]
      count > 1
    bind
      set.domain += [#domain type:"multi-type"]
    end

To figure out what our real domain is given all the potential options we have,
we look for the type with the highest defined sort.

    search
      set = [#domain-set domain: [#domain type]]
      [#define/domain type sort]
      gather/top[for:sort per:set limit:1]
    bind
      set.final += [#domain/final set type]
    end

Then, if it's a number we need to try and capture our numeric bounds by taking
the largest `from` and smallest `to`.

    search
      set = [#domain-set final domain:[#domain from]]
      gather/top[for:from per:set limit:1]
    bind
      final.from += from
    end

    search
      set = [#domain-set final domain:[#domain to]]
      gather/bottom[for:to per:set limit:1]
    bind
      final.to += to
    end

We also need to be able to do some basic arithmetic on domains to propagate
constraints forward. We'll represent these as records with the operation as a
tag and two extra attributes `a` and `b` representing the operands.

    search
      domain = if d = [#domain/add] then d
               if d = [#domain/sub] then d
               if d = [#domain/mul] then d
               if d = [#domain/div] then d
    bind
      domain <- [#domain type:"number"]
    end

Add and subtract are exactly like what you'd expect:

    search
      add = [#domain/add a b]
    bind
      add.from += a.from + b.from
    end

    search
      add = [#domain/add a b]
    bind
      add.to += a.to + b.to
    end

    search
      sub = [#domain/sub a b]
    bind
      sub.from += a.from - b.from
    end

    search
      sub = [#domain/sub a b]
    bind
      sub.to += a.to - b.to
    end

Multiplication and division have to deal with the fact that multiplying or
dividing by a negative could potentially swap the from and to. To handle this,
we'll set a maybe-from and maybe-to attribute and then resolve them to `to` and
`from` later.

    search
      mult = [#domain/mul a b]
    bind
      mult.maybe-from += a.from * b.from
    end

    search
      mult = [#domain/mul a b]
    bind
      mult.maybe-to += a.to * b.to
    end

    search
      mult = [#domain/mul a b]
      to = if a.to < 0, not(b.to) then "-Infinity"
           else if b.to < 0, not(a.to) then "-Infinity"
    bind
      mult.maybe-to += to
    end

    search
      div = [#domain/div a b]
    bind
      div.maybe-from += a.from / b.from
    end

    search
      div = [#domain/div a b]
    bind
      div.maybe-to += a.to / b.to
    end

    search
      div = [#domain/div a b]
      to = if a.to < 0, not(b.to) then "-Infinity"
           else if b.to < 0, not(a.to) then "-Infinity"
    bind
      div.maybe-to += to
    end

To resolve the maybes we created above, we just need to check if the from is
actually greater than the to or if the to is less than the from. If from or to
are missing then it represents infinity in that direction and we just take the
maybe value as it is.

    search
      domain = [#domain maybe-to]
      to = if domain.maybe-from > maybe-to then domain.maybe-from
           else if maybe-to = "-Infinity" then domain.maybe-from
           else if maybe-to != "-Infinity" then maybe-to
    bind
      domain.to += to
    end

    search
      domain = [#domain maybe-from]
      from = if domain.maybe-to < maybe-from then domain.maybe-to
             else if domain.maybe-to != "-Infinity" then maybe-from
             else if not(domain.maybe-to) then maybe-from
    bind
      domain.from += from
    end

It's also useful to be able to take an arbitrary value and turn it into a domain

    search
      domain = [#domain/from-value value]
      "number" = eve/type-of[value]
    bind
      domain <- [#domain type:"number" from:value to:value]
    end

    search
      domain = [#domain/from-value value]
      "string" = eve/type-of[value]
      not(lookup[entity:value, attribute:"tag"])
    bind
      domain <- [#domain type:"string"]
    end

    search
      domain = [#domain/from-value value]
      value = [#register]
      [#domain-set register:value final]
    bind
      domain <- [#domain/from-final #domain type:final.type final]
    end

    search
      domain = [#domain/from-final final]
    bind
      domain.from += final.from
    end

    search
      domain = [#domain/from-final final]
    bind
      domain.to += final.to
    end


Blocks and constraints
------------------------------------------------------

We need to gather what tag each e belongs to in each block. We then
need to gather our inputs and outputs for the block based on what tag they
represent.

    search
      [#scan block e a:"tag" v]
    bind
      [#block-tag block e tag-name:v]
    end

    search
      [#block-tag block e tag-name]
      [#scan block e a]
    bind
      [#block-input block tag-name a]
    end

    search
      (block e v) = if [#insert block e a:"tag" v] then (block e v)
                    else if [#remove block e a:"tag" v] then (block e v)
    bind
      [#block-tag block e tag-name:v]
    end

    search
      [#block-tag block e tag-name]
      (block a) = if [#insert block e a] then (block a)
                    else if [#remove block e a] then (block a)
    bind
      [#block-output block tag-name a]
    end

Match all the inputs with the outputs per block and create a link between those
blocks. Note that recursive blocks will have themselves as both inputs and
outputs.

    search
      [#block-input block:to tag-name a]
      [#block-output block:from tag-name a]
    bind
      [#link from to]
    end

Find blocks that serve as roots. These are either blocks that rely on an
external tag, and therefore an event, or they are blocks without scans and act
as a setup

    search
      [#external-tags tag-name]
      [#block-input block tag-name]
    bind
      block += #root
    end

    search
      block = [#block]
      not([#scan block])
      not([#if block])
    bind
      block += #setup
    end

Each setup and each root block will ultimately turn into the starting points for
chains of execution in the compiled program.

    search
      block = [#setup]
    bind
      [#chain type:"setup" start:block]
    end

    search
      block = [#root]
    bind
      [#chain type:"root" start:block]
    end

We create this chain by walking the links between blocks starting at the #root
or #setup. We also want to discover cycles here, which we figure out by looking
for a link that has the same to, but a lower level

    search
      chain = [#chain start]
      [#link from:start to]
    bind
      [#chain-link chain from:start to level:1]
    end

    search
      [#chain-link chain to:from level]
      [#link from to]
      not(
        prev = [#chain-link chain to]
        prev.level <= level
      )
      next-level = level + 1
    bind
      [#chain-link chain from to level:next-level]
    end

    search
      cur = [#chain-link chain to:from level]
      [#link from to]
      prev = [#chain-link chain to]
      prev.level <= level
    bind
      cur.back-link += prev
    end

Turn output constraints into their "real" equivalents

    search
      [#insert block e a v]
      [#remove-attribute block e a]
    bind
      [#real/set block e a v]
    end

    search
      [#function block op:"gen-id" output: e]
      [#insert block e a v]
    bind
      [#real/create block e | attribute: [a v]]
    end

    search
      [#insert block e a v]
      not([#set block e a])
      not([#create block e])
    bind
      [#real/update block e a v]
    end

    search
      [#remove block e a v]
      not([#set block e a])
    bind
      [#real/remove block e a v]
    end


Register domains
------------------------------------------------------

In order to determine what the domains of our inputs and outputs are, we need to
figure out the domains of each register in a block. We do this by creating a
domain set for each register and then by looking through the constraints to
supply domains.

    search
      register = [#register]
    bind
      [#domain-set register]
    end

For scans we know that the e register is in the record domain, an a register is
in the string domain and a v is unknown.

    search
      [#scan e]
      set = [#domain-set register:e]
    bind
      set.domain += [#domain type:"record"]
    end

    search
      [#scan a]
      set = [#domain-set register:a]
    bind
      set.domain += [#domain type:"string"]
    end

    search
      [#scan v]
      set = [#domain-set register:v]
    bind
      set.domain += [#domain type:"unknown"]
    end

For filters we need to find out ...

    search
      [#filter op:">" left right]
      set = [#domain-set register:left]
      not(right = [#register])
    bind
      set.domain += [#domain type:"number" from:right]
    end

    search
      [#filter op:">" left right]
      set = [#domain-set register:right]
      not(left = [#register])
    bind
      set.domain += [#domain type:"number" to:left]
    end

    search
      [#filter op:"<" left right]
      set = [#domain-set register:left]
      not(right = [#register])
    bind
      set.domain += [#domain type:"number" to:right]
    end

    search
      [#filter op:"<" left right]
      set = [#domain-set register:right]
      not(left = [#register])
    bind
      set.domain += [#domain type:"number" from:left]
    end

Functions...

    search
      [#function op:"+" params: [index:1 value:left] [index:2 value:right] output]
      set = [#domain-set register:output]
    bind
      set.domain += [#domain/add
                      a: [#domain/from-value output value:left]
                      b: [#domain/from-value output value:right]]
    end

    search
      [#function op:"-" params: [index:1 value:left] [index:2 value:right] output]
      set = [#domain-set register:output]
    bind
      set.domain += [#domain/sub
                      a: [#domain/from-value output value:left]
                      b: [#domain/from-value output value:right]]
    end

    search
      [#function op:"*" params: [index:1 value:left] [index:2 value:right] output]
      set = [#domain-set register:output]
    bind
      set.domain += [#domain/mul
                      a: [#domain/from-value output value:left]
                      b: [#domain/from-value output value:right]]
    end

    search
      [#function op:"/" params: [index:1 value:left] [index:2 value:right] output]
      set = [#domain-set register:output]
    bind
      set.domain += [#domain/div
                      a: [#domain/from-value output value:left]
                      b: [#domain/from-value output value:right]]
    end

Optimizing
------------------------------------------------------

While on the surface blocks tend to produce many cycles, they're often written
in such a way that if you knew the bounds of their inputs and their outputs, you
could prove that they don't actually form a cycle. Much of the optimizer is just
us using the domain information we've collected to "simulate" the program's
execution and start pruning chain-links.


Intermediate Representation (IR)
------------------------------------------------------

With a set of optimized chains, we can now generate a language agnostic IR tree
that represents the optimized program.


Code Generation
------------------------------------------------------

From the IR we can generate actual source code in some language that we can then
execute. At this point, code generation is a largely mechanical process of
looking at IR nodes and constructing code strings out of them.


Drawing
------------------------------------------------------

    search
      [#chain-link from to chain level]
    bind
      [#ui/column #links chain | children:
        [#ui/text sort:level text: "{{level}}: {{from}} -> {{to}}"]]
    end

    disabled search
      [#block-input block tag-name a]
    bind
      [#ui/column #block-tags | children:
        [#ui/text text: "{{block}} - {{tag-name}} {{a}}"]]
    end


Test
------------------------------------------------------

    commit
      [#external-tags tag-name: ("system/timer/change")]
    end

    commit
      b0 = [#block name:"b0"]
      [#insert block:b0 e:"r1" a:"tag" v:"foo"]
      [#insert block:b0 e:"r1" a:"name" v:"zomg"]

      b1 = [#block name:"b1"]
      r1 = [#register block:b1 offset:1]
      r2 = [#register block:b1 offset:2]
      r3 = [#register block:b1 offset:3]
      [#scan block:b1 e:r1 a:"tag" v:"foo"]
      [#scan block:b1 e:r1 a:"name" v:"zomg"]
      [#scan block:b1 e:r1 a:"score" v:r2]
      [#filter block:b1 op:">" left:r2 right:10]
      [#function block:b1 op:"*" params: [index:1 value: r2] [index:2 value:-1] output: r3]
      [#insert block:b1 e:r2 a:"tag" v:"yar"]

      b2 = [#block name:"b2"]
      [#scan block:b2 e:"r1" a:"tag" v:"yar"]
      [#scan block:b2 e:"r1" a:"meep" v:"r2"]
      [#insert block:b2 e:"r1" a:"meep" v:"moop"]

      b3 = [#block name:"b3"]
      [#scan block:b3 e:"r1" a:"tag" v:"system/timer/change"]
      [#insert block:b3 e:"r2" a:"tag" v:"yar"]
      [#insert block:b3 e:"r2" a:"meep" v:"foo"]
    end
